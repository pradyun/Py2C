# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

################################################################################
# From this file, the PyAST nodes is dynamically generated.
#
# This file based on Python's ASDL definitions, modified for ease of parsing,
# readability and ease of editting for adding C nodes
################################################################################

PyAST(AST): []

#-------------------------------------------------------------------------------
mod(PyAST): [int lineno]
Module(mod): [stmt* body]

#-------------------------------------------------------------------------------
stmt(PyAST): [int lineno]

FunctionDef(stmt): [
    identifier name,
    arguments args,
    stmt* body,
    expr* decorator_list,
    expr? returns
]

ClassDef(stmt): [
    identifier name,
    expr* bases,
    keyword* keywords,
    expr? starargs,
    expr? kwargs,
    stmt* body,
    expr* decorator_list
]

Return(stmt): [expr? value]

Delete(stmt): [expr* targets]
Assign(stmt): [expr* targets, expr value]
AugAssign(stmt): [expr target, operator op, expr value]

# 'else' is a keyword in Python
For(stmt): [expr target, expr iter, stmt* body, stmt* orelse]
While(stmt): [expr test, stmt* body, stmt* orelse]
If(stmt): [expr test, stmt* body, stmt* orelse]
With(stmt): [withitem* items, stmt* body]

Raise(stmt): [expr? exc, expr? cause]
Try(stmt): [stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody]
Assert(stmt): [expr test, expr? msg]

Import(stmt): [alias* names]
ImportFrom(stmt): [identifier? module, alias* names, int? level]

Global(stmt): [identifier* names]
Nonlocal(stmt): [identifier* names]
Expr(stmt): [expr value]

Pass(stmt): []
Break(stmt): []
Continue(stmt): []


#-------------------------------------------------------------------------------
expr(PyAST): [int lineno]

BoolOp(expr): [boolop op, expr* values]
BinOp(expr): [expr left, operator op, expr right]
UnaryOp(expr): [unaryop op, expr operand]
Lambda(expr): [arguments args, expr body]
IfExp(expr): [expr test, expr body, expr orelse]
Dict(expr): [expr* keys, expr* values]
Set(expr): [expr* elts]
ListComp(expr): [expr elt, comprehension* generators]
SetComp(expr): [expr elt, comprehension* generators]
DictComp(expr): [expr key, expr value, comprehension* generators]
GeneratorExp(expr): [expr elt, comprehension* generators]
Yield(expr): [expr? value]
YieldFrom(expr): [expr value]
Compare(expr): [expr left, cmpop* ops, expr* comparators]
Call(expr): [expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs]
Attribute(expr): [expr value, identifier attr, expr_context ctx]
Subscript(expr): [expr value, slice slice, expr_context ctx]
Starred(expr): [expr value, expr_context ctx]
Name(expr): [identifier id, expr_context ctx]
List(expr): [expr* elts, expr_context ctx]
Tuple(expr): [expr* elts, expr_context ctx]
Ellipsis(expr): []

# Literals with type-protection
literal(expr): []
Str(literal): [string s]
Bytes(literal): [bytes s]
Bool(literal): [bool b]
num(literal): []
Int(num): [int n]
Float(num): [float n]
Complex(num): [complex n]

#-------------------------------------------------------------------------------
expr_context(PyAST): []

Load(expr_context): []
Store(expr_context): []
Del(expr_context): []
AugLoad(expr_context): []
AugStore(expr_context): []
Param(expr_context): []

#-------------------------------------------------------------------------------
slice(PyAST): []

Slice(slice): [expr? lower, expr? upper, expr? step]
ExtSlice(slice): [slice* dims]
Index(slice): [expr value]

#-------------------------------------------------------------------------------
boolop(PyAST): []
And(boolop): []
Or(boolop): []

#===============================================================================
# Operators
#===============================================================================
operator(PyAST): []
#-------------------------------------------------------------------------------
# Arithematic
#-------------------------------------------------------------------------------
Add(operator): []
Sub(operator): []
Mult(operator): []
Div(operator): []
Mod(operator): []
Pow(operator): []
LShift(operator): []
RShift(operator): []
BitOr(operator): []
BitXor(operator): []
BitAnd(operator): []
FloorDiv(operator): []

#-------------------------------------------------------------------------------
# Unary or Bit-wise operators
#-------------------------------------------------------------------------------
unaryop(PyAST): []

Invert(unaryop): []
Not(unaryop): []
UAdd(unaryop): []
USub(unaryop): []

#-------------------------------------------------------------------------------
# Comparisions
#-------------------------------------------------------------------------------
cmpop(PyAST): []

Eq(cmpop): []
NotEq(cmpop): []
Lt(cmpop): []
LtE(cmpop): []
Gt(cmpop): []
GtE(cmpop): []
Is(cmpop): []
IsNot(cmpop): []
In(cmpop): []
NotIn(cmpop): []

#-------------------------------------------------------------------------------
# Helpers
#-------------------------------------------------------------------------------
comprehension(PyAST): [expr target, expr iter, expr* ifs]

arguments(PyAST): [
    arg* args,
    identifier? vararg,
    expr? varargannotation,
    arg* kwonlyargs,
    identifier? kwarg,
    expr? kwargannotation,
    expr* defaults,
    expr* kw_defaults
]

arg(PyAST): [identifier arg, expr? annotation]
keyword(PyAST): [identifier arg, expr value]
alias(PyAST): [identifier name, identifier? asname]
withitem(PyAST): [expr context_expr, expr? optional_vars]

# removed excepthandler as we don't need it here :)
ExceptHandler(PyAST): [expr? type, identifier? name, stmt* body]
