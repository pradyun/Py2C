#!/usr/bin/env python
"""This file has all the nodes needed to support both Python and C ASTs.
It makes it possible to translate Python code to C code.
"""

import re
from textwrap import dedent

PREFIX = dedent("""
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-

    #############################
    # DO NOT EDIT THIS FILE!!!! #
    #############################

    #------------------------------------------------------------------
    # This module is generated by '_ast_gen.py' from '_ast_nodes.txt'
    # To modify the contents of this file, don't edit directly,
    # Instead edit '_ast_nodes.txt' or '_ast_gen.py'
    #------------------------------------------------------------------

    class AST(object):
        '''Abstract AST Node'''
        def __init__(self, *args, **kwargs):
            if not hasattr(self, '_attrs'):
                raise AttributeError(
                    "An AST object should have an '_attrs' attribute"
                )
            if args and len(args) != len(self._attrs):
                msg = "{0} constructor takes 0 or {1} positional arguments"
                raise TypeError(msg.format(self.__class__.__name__, len(self._attrs)))  # noqa

            have_args = bool(args)
            self._fields = []
            self._type_nodes = []
            for (i, (name, default, type_, is_list)) in enumerate(self._attrs):
                self._fields.append(name)
                if have_args:
                    setattr(self, name, args[i])
                else:  # Guarantee attribute
                    setattr(self, name, default)
            self.__dict__.update(kwargs)


        def __eq__(self, other):
            if type(self) != type(other):
                return False
            elif self._attrs != other._attrs:
                return False
            else:
                for i in self._fields:
                    if not hasattr(other, i) or \\
                      getattr(self, i) != getattr(other, i):
                        return False
                return True

        def __ne__(self, other):
            return not self == other

    # ---------------------------------------------------------------------
    # The rest are auto-generated nodes.
    # ---------------------------------------------------------------------
""")


def indent(string, indent_with='    '):
    return '\n'.join([
        (indent_with+line)
        for line in string.strip('\r\n').splitlines()
    ])


# Helper classes (Function as AST nodes of configuration file)
class Attr(object):
    def __init__(self, name, default=None, type=None, is_list=False):
        super(Attr, self).__init__()
        self.name = name
        self.default = default
        self.type = type
        self.is_list = is_list

    def __repr__(self):
        return "Attr"+str(self)

    def __str__(self):
        return "({0.name!r}, {0.default!r}, {0.type!r}, {0.is_list})".format(self)

    def __eq__(self, other):
        return all(
            getattr(self, i) == getattr(other, i)
            for i in ["name", "type", "default", "is_list"]
        )

    def __ne__(self, other):
        return not self == other


class Node(object):
    """docstring for Node"""
    _parent_class = 'AST'
    def __init__(self, name, attrs):
        super(Node, self).__init__()
        self.name = name
        self.attrs = attrs

    def to_source(self):
        s = dedent("""
            class {self.name}({self._parent_class}):
                def __init__(self, *args, **kwargs):
                    self._attrs = {self.attrs}
                    super({self.name}, self).__init__(*args, **kwargs)
        """).strip('\n')+'\n'
        return s.format(self=self)

    def __repr__(self):
        return "Node({0.name!r}, {0.attrs})".format(self)

    def __eq__(self, other):
        return all(
            (hasattr(other, i) and getattr(self, i) == getattr(other, i))
            for i in ["attrs", "_parent_class", "name"]
        )

    def __ne__(self, other):
        return not self == other
#-------------------------------------------------------------------------------
# AST Nodes parser
#-------------------------------------------------------------------------------
import ply.lex
import ply.yacc


class Parser(object):
    """Loads the AST dynamically into classes

    This Parser parses the file passed in through method::``prepare``"""
    # This text is added to the end of each line, to signify the end of line
    end_text = r"~EOL~"
    # Lexer Stuff
    tokens = ["NAME", "END"]
    literals = "[]()*,:="
    t_NAME = r"[_a-zA-Z][_a-zA-Z0-9]*"
    t_END = end_text + "$"
    # Can be a name, list, tuple
    t_ignore = "\t "

    def t_error(self, t):
        print(t)

    # Parser Stuff
    def p_empty(self, p):
        "empty : "

    def p_result(self, p):
        "result : NAME ':' '[' node_attrs_opt ']' END"
        p[0] = Node(p[1], p[4])

    def p_node_attrs_opt1(self, p):
        "node_attrs_opt : attr more_attrs_maybe comma_opt"
        p[0] = [p[1]] + p[2]

    def p_node_attrs_opt2(self, p):
        "node_attrs_opt : empty"
        p[0] = []

    def p_more_attrs_opt1(self, p):
        "more_attrs_maybe : more_attrs_maybe ',' attr"
        p[0] = p[1] + [p[3]]

    def p_more_attrs_opt2(self, p):
        "more_attrs_maybe : empty"
        p[0] = []

    def p_comma_opt(self, p):
        """comma_opt : ','
                     | empty
        """

    def p_equal_val_opt(self, p):
        """equal_val_opt : '=' val
                         | empty
        """
        if len(p) > 2:
            p[0] = p[2]

    def p_attr(self, p):
        """attr : attr_simple
                | attr_typed
                | list_attr
        """
        p[0] = p[1]

    def p_attr1(self, p):
        "attr_simple : NAME equal_val_opt"
        p[0] = Attr(p[1], p[2], None)

    def p_attr2(self, p):
        "attr_typed : '(' NAME ':' NAME equal_val_opt ')'"
        p[0] = Attr(p[4], p[5], p[2])

    def p_attr3(self, p):
        """list_attr : '*' attr_simple
                     | '*' attr_typed"""
        p[2].is_list = True
        p[0] = p[2]

    def p_val1(self, p):
        "val : '[' ']'"
        p[0] = []

    def p_val2(self, p):
        "val : '(' ')'"
        p[0] = ()

    def p_val3(self, p):
        "val : NAME"
        p[0] = p[1]

    def p_error(self, tok):
        raise SyntaxError("There is some problem with AST nodes data passed")

    # The rest of the things
    def __init__(self, parent_class='AST'):
        super(Parser, self).__init__()
        self.parent_class = parent_class

        self.data = []

        self.lexer = ply.lex.lex(module=self)
        self.parser = ply.yacc.yacc(module=self, start="result")
        self.prefix = PREFIX

    def prepare(self, text):
        # Parse the data
        text = re.sub(r"(?m)\#.*($|\n)", "", text)
        self.data = [
            self.parser.parse(i + self.end_text)
            for i in text.splitlines()
            if i.strip()
        ]

    def write_module(self, f):
        s = ""
        s += self.prefix
        for obj in self.data:
            s += "\n\n"
            s += obj.to_source()

        # ``s`` contains the text to be written to the file
        f.write(s.strip('\n') + '\n')


# Export Nodes
from os.path import join, dirname
def prepare(module=None):
    p = Parser()
    p.prepare(open(join(dirname(__file__), "_ast_nodes.txt")).read())
    if module is None:
        module = open('dual_ast.py', 'w')
    p.write_module(module)

if __name__ == '__main__':
    prepare()
