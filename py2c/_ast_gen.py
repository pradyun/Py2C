#!/usr/bin/env python
"""
It makes it possible to translate Python code to C code.
"""

import re
from textwrap import dedent

PREFIX = dedent("""
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-

    ######################################
    # DO NOT EDIT THIS FILE DIRECTLY!!!! #
    ######################################

    #----------------------------------------------------------------------
    # This module is generated by '_ast_gen.py' from '_ast_nodes.cfg'
    # To modify the contents of this file, don't edit directly,
    # Instead edit '_ast_nodes.cfg' or '_ast_gen.py'
    #----------------------------------------------------------------------

    # ---------------------------------------------------------------------
    # The hand typed part
    # ---------------------------------------------------------------------

    class AST(object):
        '''Abstract AST Node'''
        def __init__(self, *args, **kwargs):
            if not hasattr(self, '_attrs'):
                raise AttributeError(
                    "An AST object should have an '_attrs' attribute"
                )
            if args and len(args) != len(self._attrs):
                msg = "{0} constructor takes 0 or {1} positional arguments"
                raise TypeError(msg.format(self.__class__.__name__, len(self._attrs)))  # noqa

            have_args = bool(args)
            self._fields = []
            for (i, (name, default, is_list)) in enumerate(self._attrs):
                self._fields.append(name)
                if have_args:
                    setattr(self, name, args[i])
                else:  # Guarantee attribute
                    setattr(self, name, default)
            self.__dict__.update(kwargs)

        def __eq__(self, other):
            if type(self) != type(other):
                return False
            elif self._attrs != other._attrs:
                return False
            else:
                for i in self._fields:
                    if not hasattr(other, i) or \\
                      getattr(self, i) != getattr(other, i):
                        return False
                return True

        def __ne__(self, other):
            return not self == other

    # ---------------------------------------------------------------------
    # The rest is auto-generated.
    # ---------------------------------------------------------------------
""")


# As implemented for Issue 13857 in Python 3.3
# Replicated to stay compatible with earlier Python versions
def indent(text, prefix, predicate=None):
    """Adds 'prefix' to the beginning of selected lines in 'text'.

    If 'predicate' is provided, 'prefix' will only be added to the lines
    where 'predicate(line)' is True. If 'predicate' is not provided,
    it will default to adding 'prefix' to all non-empty lines that do not
    consist solely of whitespace characters.
    """
    if predicate is None:
        def predicate(line):
            return line.strip()

    def prefixed_lines():
        for line in text.splitlines(True):
            yield (prefix + line if predicate(line) else line)
    return ''.join(prefixed_lines())


# Helper classes (Function as AST nodes of configuration file)
class Attr(object):
    def __init__(self, name, default=None, is_list=False):
        super(Attr, self).__init__()
        self.name = name
        self.default = default
        self.is_list = is_list

    def __repr__(self):
        return "Attr({0.name!r}, {0.default!r}, {0.is_list!r})".format(self)

    def to_source(self):
        return "({0.name!r}, {0.default!r}, {0.is_list!r})".format(self)

    def __eq__(self, other):
        return all(
            getattr(self, i) == getattr(other, i)
            for i in ["name", "default", "is_list"]
        )

    def __ne__(self, other):
        return not self == other


class Node(object):
    """docstring for Node"""
    _parent_class = 'AST'

    def __init__(self, name, attrs):
        super(Node, self).__init__()
        self.name = name
        self.attrs = attrs

    def to_source(self):
        s = dedent("""
            class {self.name}({self._parent_class}):
                def __init__(self, *args, **kwargs):
                    {0}
                    super({self.name}, self).__init__(*args, **kwargs)
        """).strip('\n')+'\n'
        return s.format(self.form_attrs(), self=self)

    def form_attrs(self):  # #cleanup# Dirty
        if not self.attrs:
            val = ''
        elif len(self.attrs) == 1:
            val = self.attrs[0].to_source()
        else:
            val = []
            for attr in self.attrs:
                val.append(attr.to_source())
            # Get the attribute one on each line
            val = indent(",\n".join(val), " "*12)
            # List bracket adjustment
            val = "\n"+val+"\n"+" "*8

        return "self._attrs = [{0}]".format(val)

    def __repr__(self):
        return "Node({0.name!r}, {0.attrs!r})".format(self)

    def __eq__(self, other):
        return all(
            (hasattr(other, i) and getattr(self, i) == getattr(other, i))
            for i in ["attrs", "_parent_class", "name"]
        )

    def __ne__(self, other):
        return not self == other

#-------------------------------------------------------------------------------
# AST Nodes parser
#-------------------------------------------------------------------------------
import ply.lex
import ply.yacc


class BaseError(Exception):
    pass

class LexerError(Exception):  # noqa
    pass

class ParsingError(Exception):  # noqa
    pass


class Parser(object):
    """Loads the AST dynamically into classes

    This Parser parses the file passed in through method::``prepare``"""
    # This text is added to the end of each line, to signify the end of line
    end_text = r"~EOL~"
    # Lexer Stuff
    tokens = ["NAME", "END"]
    literals = "[]()*,:="
    t_NAME = r"[_a-zA-Z][_a-zA-Z0-9]*"
    t_END = end_text + "$"
    # Can be a name, list, tuple
    t_ignore = "\t "

    def t_error(self, t):
        msg = "Unexpected character: {0!r} in Line {1}"
        raise LexerError(msg.format(t.value[0], t.lineno))

    # Parser Stuff
    def p_empty(self, p):
        "empty : "

    def p_result(self, p):
        "result : NAME ':' '[' node_attrs_opt ']' END"
        p[0] = Node(p[1], p[4])

    def p_node_attrs_opt1(self, p):
        "node_attrs_opt : attr more_attrs_maybe comma_opt"
        p[0] = [p[1]] + p[2]

    def p_node_attrs_opt2(self, p):
        "node_attrs_opt : empty"
        p[0] = []

    def p_more_attrs_opt1(self, p):
        "more_attrs_maybe : more_attrs_maybe ',' attr"
        p[0] = p[1] + [p[3]]

    def p_more_attrs_opt2(self, p):
        "more_attrs_maybe : empty"
        p[0] = []

    def p_comma_opt(self, p):
        """comma_opt : ','
                     | empty
        """

    def p_equal_val_opt(self, p):
        """equal_val_opt : '=' val
                         | empty
        """
        if p[1] == '=':
            p[0] = p[2]

    def p_attr(self, p):
        "attr : star_opt NAME equal_val_opt"
        p[0] = Attr(p[2], p[3], p[1])

    def p_star_opt(self, p):
        """star_opt : '*'
                    | empty"""
        p[0] = (p[1] == '*')

    def p_val1(self, p):
        "val : '[' ']'"
        p[0] = []

    def p_val2(self, p):
        "val : '(' ')'"
        p[0] = ()

    def p_val3(self, p):
        "val : NAME"
        p[0] = p[1]

    def p_error(self, t):
        msg = "Got unexpected token: {0}"
        raise ParsingError(msg.format(t))

    # The rest of the things
    def __init__(self):
        super(Parser, self).__init__()

        self.data = []

        self.lexer = ply.lex.lex(module=self)
        self.parser = ply.yacc.yacc(module=self, start="result")
        self.prefix = PREFIX

    def remove_comments(self, text):
        return re.sub(r"(?m)\#.*($|\n)", "", text)

    def prepare(self, text):
        # Parse the data
        text = self.remove_comments(text)
        self.data = [
            self.parser.parse(i + self.end_text)
            for i in text.splitlines()
            if i.strip()
        ]

    def write_module(self, f):
        s = ""
        s += self.prefix
        for obj in self.data:
            s += "\n\n"
            s += obj.to_source()

        # ``s`` contains the text to be written to the file
        f.write(s.strip('\n'))
        # Ensure trailing newline
        f.write('\n')


# Export Nodes txt file (Not used in package)
from os.path import join, dirname
ast_nodes_fname = join(dirname(__file__), "_ast_nodes.cfg")


def prepare(file):
    p = Parser()
    p.prepare(open(ast_nodes_fname).read())
    p.write_module(file)

if __name__ == '__main__':
    with open('dual_ast.py', 'w') as f:
        f.truncate()
        prepare(f)
    print("Generated 'dual_ast.py'")
