#! /usr/bin/env python
"""
AST nodes file generator
This file generates the dual_ast that we use to translate Python code to C code.
It makes it possible to translate Python code to C code without multiple AST
systems.
"""

import re
from textwrap import dedent

# indented to allow for code-collapsing
PREFIX = dedent("""
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-

    ######################################
    # DO NOT EDIT THIS FILE DIRECTLY!!!! #
    ######################################

    #----------------------------------------------------------------------
    # This module is generated by '_ast_gen.py' from '_ast_nodes.cfg'
    # To modify the contents of this file, don't edit directly,
    # Instead edit '_ast_nodes.cfg' or '_ast_gen.py'
    #----------------------------------------------------------------------

    # ---------------------------------------------------------------------
    # The hand typed part
    # ---------------------------------------------------------------------


    class AST(object):
        '''Abstract AST Node'''
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            else:
                for i in self._fields:
                    if not hasattr(other, i) or getattr(self, i) != getattr(other, i):  # noqa
                        return False
                return True

        def __ne__(self, other):
            return not self == other

        def __repr__(self):
            attrs = ", ".join(
                "{0}={1!r}".format(field, getattr(self, field))
                for field in self._fields
            )
            return "{self.__class__.__name__}({attrs})".format(self=self, attrs=attrs)  # noqa

        def _get_val(self, text):
            # print(text)
            return eval(text)

    # ---------------------------------------------------------------------
    # The rest is auto-generated.
    # ---------------------------------------------------------------------
""")


# As implemented for Issue 13857 in Python 3.3
# Replicated to stay compatible with earlier Python versions
def indent(text, prefix, predicate=None):
    """Adds 'prefix' to the beginning of selected lines in 'text'.

    If 'predicate' is provided, 'prefix' will only be added to the lines
    where 'predicate(line)' is True. If 'predicate' is not provided,
    it will default to adding 'prefix' to all non-empty lines that do not
    consist solely of whitespace characters.
    """
    if predicate is None:
        def predicate(line):
            return line.strip()

    def prefixed_lines():
        for line in text.splitlines(True):
            yield (prefix + line if predicate(line) else line)
    return ''.join(prefixed_lines())


# Helper classes (Function as AST nodes of configuration file)
class Attr(object):
    """Represents an attribute of a Node
    """
    def __init__(self, name, default=None):
        super(Attr, self).__init__()
        self.name = name
        self.default = default

    def __repr__(self):
        return "Attr({0.name!r}, {0.default!r})".format(self)

    def signature(self):
        s = "{self.name}"
        if self.default is not None:
            s += "={self.default}"
        return s.format(self=self)

    def setter(self):
        return "self.{0} = {0}".format(self.name)

    def __eq__(self, other):
        return all(
            getattr(self, i) == getattr(other, i)
            for i in ["name", "default"]
        )

    def __ne__(self, other):
        return not self == other


class Node(object):
    """Represents a definition
    """
    default_parent_class = 'AST'

    def __init__(self, name, attrs, parent_class=None):
        super(Node, self).__init__()
        if parent_class is None:
            parent_class = self.default_parent_class
        self.name = name
        self.attrs = attrs
        self.parent_class = parent_class

    def to_source(self):
        s = dedent("""
            class {self.name}({self.parent_class}):
                _fields = {_fields}
                def __init__({signature}):
            {setters}
        """)
        return s.format(
            self=self,
            signature=self._signature(),
            setters=self._setters(),
            _fields=list(map(lambda x: x.name, self.attrs))
        )

    def _signature(self):
        return ", ".join(
            ["self"] + list(map(lambda x: x.signature(), self.attrs))
        )

    def _setters(self):
        return indent(
            "\n".join(map(lambda x: x.setter(), self.attrs)) or "pass",
            " " * 8
        )

    def __repr__(self):
        return "Node({0.name!r}, {0.attrs!r})".format(self)

    def __eq__(self, other):
        return all(
            (hasattr(other, i) and getattr(self, i) == getattr(other, i))
            for i in ["attrs", "parent_class", "name"]
        )

    def __ne__(self, other):
        return not self == other

#-------------------------------------------------------------------------------
# AST Nodes parser
#-------------------------------------------------------------------------------
import ply.lex
import ply.yacc


class BaseError(Exception):
    """Serves as the base for all errors in this module
    """


class LexerError(BaseError):
    """Error while tokenizing the code
    """


class ParsingError(BaseError):
    """Error while parsing the code
    """


class Lexer(object):
    """Tokenizes the AST configuration text
    """
    states = [
        ('string', 'exclusive')
    ]
    # Lexer Stuff
    tokens = ["NAME", "STRING"]
    literals = "[]()*,:="
    t_string_ignore = ""
    t_ignore = "\n\t "
    t_NAME = r"[_a-zA-Z][_a-zA-Z0-9]*"

    def t_INITIAL_stringstart(self, t):
        r'"'
        self.str_start = t.lexpos
        t.lexer.begin("string")

    def t_string_end(self, t):
        r'(?<!\\)"'
        end = t.lexpos
        t.type = "STRING"
        t.lexpos = self.str_start
        t.value = t.lexer.lexdata[self.str_start:end + 1]
        t.lexer.begin("INITIAL")
        return t

    # For bad characters, we just skip over it
    def t_string_error(self, t):
        t.lexer.skip(1)

    def t_error(self, t):
        msg = "Unexpected character: {char!r} in Line {lineno}"
        raise LexerError(msg.format(
            char=t.value[0],
            lineno=t.lineno
        ))


class Parser(object):
    """Parses the AST configuration file text
    """
    #----------------------------------------------------------------------
    # Lexer
    states = [
        ('string', 'exclusive')
    ]
    # Lexer Stuff
    tokens = ["NAME", "STRING"]
    literals = "[]()*,:="

    # Parser
    def p_empty(self, p):
        "empty : "

    def p_goal1(self, p):
        "goal : result goal"
        p[0] = [p[1]] + p[2]

    def p_goal2(self, p):
        "goal : empty"
        p[0] = []

    def p_result(self, p):
        "result : NAME name_in_parens_opt ':' '[' node_attrs_opt ']'"
        p[0] = Node(p[1], p[5], p[2])

    def p_name_in_parens_opt(self, p):
        """name_in_parens_opt : '(' NAME ')'
                              | empty
        """
        if len(p) > 2:
            p[0] = p[2]
        else:
            p[0] = None

    def p_node_attrs_opt1(self, p):
        "node_attrs_opt : attr more_attrs_maybe comma_opt"
        p[0] = [p[1]] + p[2]

    def p_node_attrs_opt2(self, p):
        "node_attrs_opt : empty"
        p[0] = []

    def p_more_attrs_opt1(self, p):
        "more_attrs_maybe : more_attrs_maybe ',' attr"
        p[0] = p[1] + [p[3]]

    def p_more_attrs_opt2(self, p):
        "more_attrs_maybe : empty"
        p[0] = []

    def p_comma_opt(self, p):
        """comma_opt : ','
                     | empty
        """

    def p_equal_val_opt(self, p):
        """equal_val_opt : '=' val
                         | empty
        """
        if p[1] == '=':
            p[0] = p[2]

    def p_attr(self, p):
        "attr : NAME equal_val_opt"
        p[0] = Attr(p[1], p[2])

    def p_val1(self, p):
        "val : '[' ']'"
        p[0] = '[]'

    def p_val2(self, p):
        "val : '(' ')'"
        p[0] = '()'

    def p_val3(self, p):
        "val : NAME"
        p[0] = p[1]

    def p_val4(self, p):
        "val : STRING"
        p[0] = p[1]

    def p_error(self, t):
        msg = "Got unexpected token: {0}"
        raise ParsingError(msg.format(t))


class ConfigFileLoader(object):
    """Processes the configuration text and produces output
    """
    def __init__(self):
        super(ConfigFileLoader, self).__init__()
        self.data = []

        self.lexer = ply.lex.lex(module=Lexer())
        self.parser = ply.yacc.yacc(module=Parser(), start="goal")
        self.prefix = PREFIX

    def remove_comments(self, text):
        return re.sub(r"(?m)\#.*($|\n)", "", text)

    def prepare(self, text):
        # Parse the data
        text = self.remove_comments(text)
        # self.lexer.input(text)
        # for i in self.lexer:
        #     print(i)
        self.data = self.parser.parse(text, lexer=self.lexer)

    def write_module(self, f):
        s = []
        s.append(self.prefix)
        for obj in self.data:
            s.append(obj.to_source())

        # ``s`` contains the code of classes to be written to the file
        f.write("\n\n".join(s).strip('\n'))
        # Ensure trailing newline
        f.write('\n')


# Export Nodes txt file (Not used in package)
from os.path import join, dirname
ast_nodes_fname = join(dirname(__file__), "_ast_nodes.cfg")


def generate(file):
    p = ConfigFileLoader()
    p.prepare(open(ast_nodes_fname).read())
    p.write_module(file)

if __name__ == '__main__':
    with open('_dual_ast.py', 'w') as f:
        f.truncate()
        generate(f)
    print("Generated '_dual_ast.py'")
    # import sys
    # p = Parser()
    # p.prepare('Print(stmt) : [dest, values, sep=" ", end="\\n"]')
    # p.write_module(sys.stdout)
