################################################################################
# From this file, the dual AST nodes is dynamically generated.
#
# Syntax of definitions in EBNF:
#
#     Node = NAME, ['(', NAME, ')'], ':', '[', [node_attrs], ']';
#     node_attrs = attr, [{',', attr}], [','];
#     attr = attr_simple | attr_list_simple;
#     val = '[', ']' | '(', ')' | NAME;
#     attr_simple = NAME ['=', val];
#     attr_list_simple = '*', attr_simple;
#
# You can define an optional base class for a node.
#
################################################################################

#-------------------------------------------------------------------------------
# Python
#-------------------------------------------------------------------------------

# Compatibility Notes
#    - arguments
#        The node's first four arguments are present in both Python 2 & 3.
#        The following arguments are in Python 3 only
#    - Raise
#        The node takes atleast 2 arguments and atmost 3 arguments.
#    -

# Base nodes
boolop(AST) : []
cmpop(AST) : []
excepthandler(AST) : []
expr(AST) : []
expr_context(AST) : []
mod(AST) : []
slice(AST) : []
stmt(AST) : []
unaryop(AST) : []
operator(AST) : []

# Helper nodes
alias(AST) : [name, asname]
arguments(AST) : [args, vararg, defaults, kwarg, varargannotation=None, kwonlyargs=None, kwargannotation=None, kw_defaults=None]
comprehension(AST) : [target, iter, ifs]
keyword(AST) : [arg, value]

# Arithematic Operators
operator(AST) : []
Add(operator) : []
BitAnd(operator) : []
BitOr(operator) : []
BitXor(operator) : []
Div(operator) : []
FloorDiv(operator) : []
LShift(operator) : []
Mod(operator) : []
Mult(operator) : []
Pow(operator) : []
RShift(operator) : []
Sub(operator) : []

# Boolean Operators
And(boolop) : []
Or(boolop) : []

# Comparision Operators
Eq(cmpop) : []
Gt(cmpop) : []
GtE(cmpop) : []
In(cmpop) : []
Is(cmpop) : []
IsNot(cmpop) : []
Lt(cmpop) : []
LtE(cmpop) : []
NotEq(cmpop) : []
NotIn(cmpop) : []

# Unary Operators
UAdd(unaryop) : []
USub(unaryop) : []
Invert(unaryop) : []
Not(unaryop) : []

# Statements
Assert(stmt) : [test, msg]
Assign(stmt) : [targets, value]
AugAssign(stmt) : [target, op, value]
Break(stmt) : []
ClassDef(stmt) : [name, bases, body, decorator_list, keywords=None, starargs=None, kwargs=None]
Continue(stmt) : []
Delete(stmt) : [targets]
Exec(stmt) : [body, globals, locals]
Expr(stmt) : [value]
For(stmt) : [target, iter, body, orelse]
FunctionDef(stmt) : [name, args, body, decorator_list, returns=None]
Global(stmt) : [names]
If(stmt) : [test, body, orelse]
Import(stmt) : [names]
ImportFrom(stmt) : [module, names, level]
Pass(stmt) : []
Print(stmt) : [dest, values, nl]
Raise(stmt) : [type_exc, ins_cause, tback=None] # Merge Py2 and Py3 arguments
Return(stmt) : [value]
TryExcept(stmt) : [body, handlers, orelse]
TryFinally(stmt) : [body, finalbody]
While(stmt) : [test, body, orelse]
With(stmt) : [context_expr, optional_vars, body]

# Slices
ExtSlice(slice) : [dims]
Index(slice) : [value]
Slice(slice) : [lower, upper, step]

# Contexts (Just for compatibility with ast)
AugLoad(expr_context) : []
AugStore(expr_context) : []
Del(expr_context) : []
Load(expr_context) : []
Param(expr_context) : []
Store(expr_context) : []

# Expressions
Attribute(expr) : [value, attr, ctx]
BinOp(expr) : [left, op, right]
BoolOp(expr) : [op, values]
Call(expr) : [func, args, keywords, starargs, kwargs]
Compare(expr) : [left, ops, comparators]
Dict(expr) : [keys, values]
DictComp(expr) : [key, value, generators]
ExceptHandler(excepthandler) : [type, name, body]
GeneratorExp(expr) : [elt, generators]
IfExp(expr) : [test, body, orelse]
Lambda(expr) : [args, body]
List(expr) : [elts, ctx]
ListComp(expr) : [elt, generators]
Name(expr) : [id, ctx]
Num(expr) : [n]
Repr(expr) : [value]
Set(expr) : [elts]
SetComp(expr) : [elt, generators]
Str(expr) : [s]
Subscript(expr) : [value, slice, ctx]
Tuple(expr) : [elts, ctx]
UnaryOp(expr) : [op, operand]
Yield(expr) : [value]

# Containers
Expression(mod) : [body]
Interactive(mod) : [body]
Module(mod) : [body]
Suite(mod) : [body]

# Py3 only nodes
arg(AST) : [arg, annotation]
withitem(AST) : [context_expr, optional_vars]

Nonlocal(stmt) : [names]
Starred(expr) : [value, ctx]
Try(stmt) : [body, handlers, orelse, finalbody]
YieldFrom(expr) : [value]
Bytes(expr) : [s]

# Special
Ellipsis(AST) : [] # Couldn't think of any other type
