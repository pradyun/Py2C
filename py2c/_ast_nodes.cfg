#-------------------------------------------------------------------------------
# From this file, the dual AST nodes is dynamically generated.
#
# Syntax of definitions in EBNF:
#
#     Node = NAME, ':', '[', [node_attrs], ']';
#     node_attrs = attr, [{',', attr}], [','];
#     attr = attr_simple | attr_list_simple;
#     val = '[', ']' | '(', ')' | NAME;
#     attr_simple = NAME ['=', val];
#     attr_list_simple = '*', attr_simple;
#
# In this definition of tokens,
#  - The token values are optionally typed. Any object can't be assign in a
#    place where a child token should be. Only none or the token that isinstance
#    of the class specified is allowed.
#
#-------------------------------------------------------------------------------


# Operators
Add:  []
Sub:  []
Mult: []
Div:  []
Mod:  []

# Comparator
Eq:   []
NotEq:[]
Gt:   []
GtE:  []
Lt:   []
LtE:  []

# Bool operators
And:  []
Or:   []
Not:  []
USub: []

# Basic nodes
Int: [n]
Float: [n]
Str: [s]
Name: [id]

# A node for simplicity, a call to printf or << to cout is more complex in the AST!
Print: [dest, values, sep, end]

# Flow control
Pass: []
Continue: []
If: [test, *body, orelse]
While: [test, *body, orelse]
IfExp: [test, *body, orelse]


# Operations
BinOp: [op, left, right]
BoolOp: [op, values]
UnaryOp: [op, operand]

# Assignments
Assign: [type, targets, value]
AugAssign: [target, op, value]

# Function related
FunctionDef: [type, name, arguments]
Call: [func, args]
Return: [value]

# Others
Attribute: [value, attr]
Compare: [left, ops, comparators]
Module: [*body=[]]

