################################################################################
# From this file, the dual AST nodes is dynamically generated.
#
# Syntax of definitions in EBNF:
#
#     Node = NAME, ['(', NAME, ')'], ':', '[', [node_attrs], ']';
#     node_attrs = attr, [{',', attr}], [','];
#     attr = attr_simple | attr_list_simple;
#     val = '[', ']' | '(', ')' | NAME;
#     attr_simple = NAME ['=', val];
#     attr_list_simple = '*', attr_simple;
#
# You can define an optional base class for a node.
#
################################################################################


# Base nodes
boolop(AST) : []
cmpop(AST) : []
excepthandler(AST) : []
expr(AST) : []
expr_context(AST) : []
mod(AST) : []
slice(AST) : []
stmt(AST) : []
unaryop(AST) : []
operator(AST) : []

#-------------------------------------------------------------------------------
# Common
#-------------------------------------------------------------------------------

# Containers
Expression(mod) : [body]
Interactive(mod) : [body]
Module(mod) : [body]
Suite(mod) : [body]

# Flow control
Break(stmt) : []
Py_For(stmt) : [target, iter, body, orelse]
If(stmt) : [test, body, orelse]
Return(stmt) : [value]
While(stmt) : [test, body, orelse]

# Operators
BinOp(expr) : [left, op, right]
BoolOp(expr) : [op, values]
UnaryOp(expr) : [op, operand]

# Other nodes
ClassDef(stmt) : [
    name,
    bases,
    body,
    decorator_list,
    keywords=None,
    starargs=None,
    kwargs=None
]
# Returns can be a Type!
FunctionDef(stmt) : [name, args, body, decorator_list, returns=None]
Str(expr) : [s]

#-------------------------------------------------------------------------------
# Python
#-------------------------------------------------------------------------------

# Helper nodes
alias(AST) : [name, asname]
arguments(AST) : [
    args,
    vararg,
    defaults,
    kwarg,
    varargannotation=None,
    kwonlyargs=None,
    kwargannotation=None,
    kw_defaults=None
]
comprehension(AST) : [target, iter, ifs]
keyword(AST) : [arg, value]

# Arithematic Operators
Add(operator) : []
BitAnd(operator) : []
BitOr(operator) : []
BitXor(operator) : []
Div(operator) : []
FloorDiv(operator) : []
LShift(operator) : []
Mod(operator) : []
Mult(operator) : []
Pow(operator) : []
RShift(operator) : []
Sub(operator) : []

# Boolean Operators
And(boolop) : []
Or(boolop) : []

# Comparision Operators
Eq(cmpop) : []
Gt(cmpop) : []
GtE(cmpop) : []
In(cmpop) : []
Is(cmpop) : []
IsNot(cmpop) : []
Lt(cmpop) : []
LtE(cmpop) : []
NotEq(cmpop) : []
NotIn(cmpop) : []

# Unary Operators
UAdd(unaryop) : []
USub(unaryop) : []
Invert(unaryop) : []
Not(unaryop) : []

# Statements
Assert(stmt) : [test, msg]
Assign(stmt) : [targets, value]
AugAssign(stmt) : [target, op, value]
Continue(stmt) : []
Delete(stmt) : [targets]
Exec(stmt) : [body, globals, locals]
Expr(stmt) : [value]
Global(stmt) : [names]
Import(stmt) : [names]
ImportFrom(stmt) : [module, names, level]
Pass(stmt) : []
Print(stmt) : [dest, values, nl]
Raise(stmt) : [type_exc, ins_cause, tback=None] # Merge Py2 and Py3 arguments
TryExcept(stmt) : [body, handlers, orelse]
TryFinally(stmt) : [body, finalbody]
With(stmt) : [context_expr, optional_vars, body]

# Slices
ExtSlice(slice) : [dims]
Index(slice) : [value]
Slice(slice) : [lower, upper, step]

# Contexts (Just for compatibility with ast)
AugLoad(expr_context) : []
AugStore(expr_context) : []
Del(expr_context) : []
Load(expr_context) : []
Param(expr_context) : []
Store(expr_context) : []

# Expressions
Attribute(expr) : [value, attr, ctx]
Call(expr) : [func, args, keywords, starargs, kwargs]
Compare(expr) : [left, ops, comparators]
Dict(expr) : [keys, values]
DictComp(expr) : [key, value, generators]
ExceptHandler(excepthandler) : [type, name, body]
GeneratorExp(expr) : [elt, generators]
IfExp(expr) : [test, body, orelse]
Lambda(expr) : [args, body]
List(expr) : [elts, ctx]
ListComp(expr) : [elt, generators]
Name(expr) : [id, ctx]
Num(expr) : [n]
Repr(expr) : [value]
Set(expr) : [elts]
SetComp(expr) : [elt, generators]
Subscript(expr) : [value, slice, ctx]
Tuple(expr) : [elts, ctx]
Yield(expr) : [value]

# Py3 only nodes
arg(AST) : [arg, annotation]
withitem(AST) : [context_expr, optional_vars]

Nonlocal(stmt) : [names]
Starred(expr) : [value, ctx]
Try(stmt) : [body, handlers, orelse, finalbody]
YieldFrom(expr) : [value]
Bytes(expr) : [s]

# Special
Ellipsis(AST) : [] # Base classes: Py2 -> slice, Py3 -> expr


#-------------------------------------------------------------------------------
# C
#-------------------------------------------------------------------------------



# Typed literals
Int(Num): [n]
Float(Num): [n]
Char(Str) : [s]

# Enum
EnumDecl: [name, items]
EnumItem: [name, value]

Decl(stmt): [
    name,
    modifiers,
    storage,
    dimensions=[],
    funcspec,
    type,
    init,
    bitsize,
    is_ptr=False,
]

## Flow control
# Loops (While is common)
C_For(stmt) : [init, cond, update, body]
DoWhile(stmt) : [test, body, orelse]
# Switch
Switch(stmt): [cond, body]
Case(expr): [value, body]
Default(expr): [body]

Block(stmt): [body] # A block can be anywhere a statemnt can!

# Goto
Goto(stmt): [label]
Label(stmt): [name, body]
