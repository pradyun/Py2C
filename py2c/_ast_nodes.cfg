# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

################################################################################
# From this file, the dual AST nodes is dynamically generated.
#
# Syntax of definitions in EBNF:
#
#     Node = NAME, ['(', NAME, ')'], ':', '[', [node_attrs], ']';
#     node_attrs = attr, [{',', attr}], [','];
#     attr = attr_simple | attr_list_simple;
#     val = '[', ']' | '(', ')' | NAME;
#     attr_simple = NAME ['=', val];
#     attr_list_simple = '*', attr_simple;
#
# From the definition, we can see that:
#  - There is an optional base class for the node
#  - There is an optional default value for the attributes
#  - Each Node has 0 or more attributes
#
################################################################################


# Base nodes
boolop(AST) : []
cmpop(AST) : []
excepthandler(AST) : []
expr(AST) : []
expr_context(AST) : []
mod(AST) : []
slice(AST) : []
stmt(AST) : []
unaryop(AST) : []
operator(AST) : []

#-------------------------------------------------------------------------------
# Common
#-------------------------------------------------------------------------------

# Containers
Module(mod) : [body]

# Flow control
Break(stmt) : []
Py_For(stmt) : [target, iter, body, orelse]
If(stmt) : [test, body, orelse]
Return(stmt) : [value]
While(stmt) : [test, body, orelse]

# Operators
BinOp(expr) : [left, op, right]
BoolOp(expr) : [op, values]
UnaryOp(expr) : [op, operand]

# Other nodes
ClassDef(stmt) : [
    name,
    bases,
    body,
    decorator_list,
    keywords=None,
    starargs=None,
    kwargs=None
]

FunctionDef(stmt) : [
    # Discard all annotations
    name,
    args,
    body,
    decorator_list,
    returns=None    # 'returns' => a type in C!
]

# Expressions
Str(expr) : [s]
Name(expr) : [id, types]

# Statements
Assert(stmt) : [test, msg=""]
Assign(stmt) : [targets, value]
Attribute(expr) : [value, attr]
Print(stmt) : [dest, values, sep=" ", end="\n"]
Pass(stmt) : []

# Arithematic operators
Add(operator) : []
Div(operator) : []
FloorDiv(operator) : []
LShift(operator) : []
Mod(operator) : []
Mult(operator) : []
Pow(operator) : []
RShift(operator) : []
Sub(operator) : []

# Boolean operators
And(boolop) : []
Or(boolop) : []

# Comparision operators
Eq(cmpop) : []
Gt(cmpop) : []
GtE(cmpop) : []
Lt(cmpop) : []
LtE(cmpop) : []
NotEq(cmpop) : []

# Bitwise operators
BitAnd(operator) : []
BitOr(operator) : []
BitXor(operator) : []

# Unary operators
UAdd(unaryop) : []
USub(unaryop) : []
Invert(unaryop) : []
Not(unaryop) : []

# Expressions
Call(expr) : [
    func,
    args,
    # Maintain compatibility across languages
    keywords=None,
    starargs=None,
    kwargs=None
]

#-------------------------------------------------------------------------------
# Python specific
#-------------------------------------------------------------------------------

# Helper nodes
alias(AST) : [name, asname]
arguments(AST) : [
    args,
    vararg,
    defaults,
    kwarg,
    varargannotation=None,
    kwonlyargs=None,
    kwargannotation=None,
    kw_defaults=None
]
comprehension(AST) : [target, iter, ifs]
keyword(AST) : [arg, value]

# Comparision operators
In(cmpop) : []
Is(cmpop) : []
IsNot(cmpop) : []
NotIn(cmpop) : []

# Statements
AugAssign(stmt) : [target, op, value]
Continue(stmt) : []
Delete(stmt) : [targets]
Exec(stmt) : [body, globals, locals]
Expr(stmt) : [value]
Global(stmt) : [names]
Import(stmt) : [names]
ImportFrom(stmt) : [module, names, level]
Raise(stmt) : [type_exc, ins_cause, tback=None] # Merge Py2 and Py3 arguments
TryExcept(stmt) : [body, handlers, orelse]
TryFinally(stmt) : [body, finalbody]
With(stmt) : [context_expr, optional_vars, body]

# Slices
ExtSlice(slice) : [dims]
Index(slice) : [value]
Slice(slice) : [lower, upper, step]

# Contexts (Just for compatibility with ast)
AugLoad(expr_context) : []
AugStore(expr_context) : []
Del(expr_context) : []
Load(expr_context) : []
Param(expr_context) : []
Store(expr_context) : []

Compare(expr) : [left, ops, comparators]
Dict(expr) : [keys, values]
DictComp(expr) : [key, value, generators]
ExceptHandler(excepthandler) : [type, name, body]
GeneratorExp(expr) : [elt, generators]
IfExp(expr) : [test, body, orelse]
Lambda(expr) : [args, body]
List(expr) : [elts]
ListComp(expr) : [elt, generators]
Num(expr) : [n]
Repr(expr) : [value]
Set(expr) : [elts]
SetComp(expr) : [elt, generators]
Subscript(expr) : [value, slice]
Tuple(expr) : [elts]
Yield(expr) : [value]

# Py3 only nodes
arg(AST) : [arg, annotation]
withitem(AST) : [context_expr, optional_vars]

Nonlocal(stmt) : [names]
Starred(expr) : [value]
Try(stmt) : [body, handlers, orelse, finalbody]
YieldFrom(expr) : [value]
Bytes(expr) : [s]

# Special
Ellipsis(AST) : [] # Base classes: Py2 -> slice, Py3 -> expr

#-------------------------------------------------------------------------------
# C specific
#-------------------------------------------------------------------------------

# Typed literals
Int(Num): [n]
Float(Num): [n]
Char(Str) : [s]

# Enum
EnumDecl: [name, items]
EnumItem: [name, value]

# Convert first assignments to a variable name into this
Decl(stmt): [
    name,
    modifiers,
    storage,
    funcspec,
    type,
    init,
    bitsize,
    dimensions=[],
    is_ptr=False
]

## Flow control
# Loops (While is common)
C_For(stmt) : [init, cond, update, body]
DoWhile(stmt) : [test, body, orelse]
# Switch
Switch(stmt): [cond, body]
Case(expr): [value, body]
Default(expr): [body]

Block(stmt): [body] # A block can be anywhere a statement can!

# Goto
Goto(stmt): [label]
Label(stmt): [name, body]
