"""Tests for the generation of the AST nodes from the definitions.
"""
import warnings
import unittest
from textwrap import dedent

import py2c._ast_gen as ast_gen
# It is refered multiple times
Node = ast_gen.Node


class ParserTestCase(unittest.TestCase):
    """Abstract TestCase: Tests for Parsing of the AST file declarations.
    """
    def setUp(self):
        self.parser = ast_gen.Parser()

    def template(self, test_string, expected):
        result = self.parser.parse(dedent(test_string))
        self.assertEqual(result, expected)


class CommentTestCase(ParserTestCase):
    """Tests for Parser's comment handling capability
    """

    def template(self, test_string, expected):
        self.assertEqual(
            ast_gen.Parser().remove_comments(test_string),
            expected
        )

    def test_comment_only_line(self):
        "Checks if Parser handles empty lines with comments correctly"
        self.template(
            "#test: [a,string]",
            ""
        )

    def test_comment_empty_line(self):
        "Checks if Parser handles empty lines with comments correctly"
        self.template(
            "",
            ""
        )

    def test_comment_no_arg(self):
        "Checks if Parser handles Nodes with comments correctly"
        self.template(
            "foo: [] #test: [a,string]",
            "foo: [] "
        )

    def test_comment_newline(self):
        "Checks if Parser handles multiple lines with comments correctly"
        self.template(
            "foo:[] # test\nblah: []",
            "foo:[] \nblah: []"
        )


class PropertyTestCase(ParserTestCase):
    """Tests for Parser's parsing of the Definitions
    """

    def test_no_attr_no_parent(self):
        self.template(
            "foo: []",
            [Node('foo', None, [])]
        )

    def test_no_attr_parent(self):
        self.template(
            "foo(AST): []",
            [Node('foo', 'AST', [])]
        )

    def test_attr_no_parent(self):
        self.template(
            "foo: [int bar]",
            [Node(
                'foo',
                None,
                [('int', 'bar', 'NEEDED')],
            )]
        )

    def test_attr_parent(self):
        self.template(
            "foo(AST): [int bar]",
            [Node(
                'foo',
                'AST',
                [('int', 'bar', 'NEEDED')],
            )]
        )

    def test_modifiers(self):
        self.template(
            "FooBar: (int foo, int+ bar, int* baz, int? spam)",
            [
                Node(
                    "FooBar",
                    None,
                    [
                        ('foo', 'int', 'NEEDED'),
                        ('bar', 'int', 'ONE_OR_MORE'),
                        ('baz', 'int', 'ZERO_OR_MORE'),
                        ('spam', 'int', 'OPTIONAL'),
                    ]
                )
            ]
        )

    def test_multiple(self):
        self.template(
            """
            base1: [int field1]
            base2(base1): [int field2]
            obj(base2): []
            """,
            [
                Node(
                    "base1", None,
                    [("field1", "int", "NEEDED")]
                ),
                Node(
                    "base2", "base1",
                    [("field2", "int", "NEEDED")]
                ),
                Node(
                    "obj", "base2",
                    []
                ),
            ]
        )


class ParserWarningTestCase(ParserTestCase):
    """Tests for warnings generated by Parser
    """
    def test_duplicate(self):
        s = dedent("""
            some_node: [int bar]
            some_node: [int baz]
        """).strip()

        with warnings.catch_warnings(record=True) as catcher:
            # Cause all warnings to always be triggered.
            warnings.simplefilter("always")
            # Trigger a warning.
            self.parser.parse(s)
            # Verify some things
            assert len(catcher) == 1
            w = catcher[0]
            assert issubclass(w.category, UserWarning)
            assert "duplicate" in str(w.message)
            assert "some_node" in str(w.message)


class SourceGeneratorTestCase(unittest.TestCase):
    """Tests for the code generation
    """
    def template(self, data, expected_output):
        self.src_gen = ast_gen.SourceGenerator()
        generated = self.src_gen.generate_sources(data)

        self.assertEqual(
            dedent(expected_output).strip(), generated.strip()
        )

    def test_no_attr_no_parent(self):
        self.template(
            [Node('foo', None, [])],
            """
            class FooBar(object):
                _fields = []
            """
        )

    def test_no_attr_parent(self):
        self.template(
            [Node('foo', 'AST', [])],
            """
            class FooBar(AST):
                _fields = AST._fields
            """
        )

    def test_attr_no_parent(self):
        self.template(
            [Node(
                'FooBar',
                None,
                [('int', 'bar', 'NEEDED')],
            )],
            """
            class FooBar(object):
                _fields = [
                    ('bar', int, NEEDED),
                ]
            """
        )

    def test_attr_parent(self):
        self.template(
            [Node(
                'foo',
                'AST',
                [('int', 'bar', 'NEEDED')],
            )],
            """
            class FooBar(AST):
                _fields = AST._fields + [
                    ('bar', int, NEEDED),
                ]
            """
        )

    def test_modifiers(self):
        self.template(
            [Node(
                'FooBar',
                'AST',
                [
                    ('foo', 'int', 'NEEDED'),
                    ('bar', 'int', 'ONE_OR_MORE'),
                    ('baz', 'int', 'ZERO_OR_MORE'),
                    ('spam', 'int', 'OPTIONAL'),
                ]
            )],
            """
            class FooBar(AST):
                _fields = AST._fields + [
                    ('foo', int, NEEDED),
                    ('bar', int, ONE_OR_MORE),
                    ('baz', int, ZERO_OR_MORE),
                    ('spam', int, OPTIONAL),
                ]
            """
        )

    def test_multiple(self):
        self.template(
            """
            base1: [int field1]
            base2(base1): [int field2]
            obj(base2): []
            """,
            """
            class base1(object):
                _fields = [
                    ('field1', int, NEEDED),
                ]


            class base2(base1):
                _fields = base1.fields + [
                    ('field2', int, NEEDED),
                ]


            class obj(base2):
                _fields = base2.fields
            """
        )


if __name__ == '__main__':
    unittest.main(buffer=True)
